#!/usr/bin/env node

/* eslint no-console: 0 */
var _ = require('underscore');
var Promise = require('bluebird');
var WebSocket = require('ws');
var minimist = require('minimist');
var rp = require('request-promise');
var path = require('path');
var cli_errors = require('juttle/lib/cli/errors');
var rp_errors = require('request-promise/errors');
var open = require('open');
var JuttleBundler = require('../lib/bundler');
var chokidar = require('chokidar');
var fs = require('fs');
var crypto = require('crypto');

var defaults = {
    'outriggerd': 'localhost:8080',
    'topic': 'default'
};

var opts = minimist(process.argv.slice(2));

function usage() {
    console.log('usage: [--outriggerd <hostname:port>] [--help] [COMMAND] [OPTIONS]');
    console.log('   [COMMAND]: one of the following, with the following options:');
    console.log('         subscribe (--job <job-id>|--observer <observer-id>)');
    console.log('         list_jobs [--job <job-id>]');
    console.log('         list_observers');
    console.log('         push --path <path> --topic <rendezvous-topic>');
    console.log('         watch --path <path> --topic <rendezvous-topic>');
    console.log('         run --path <path> [--observer <observer-id>]');
    console.log('         delete --job <job-id>');
    console.log('         get_inputs --path <path> --input name=val [--input name=val ...]');
    console.log('         browser --path <path>');
    console.log('   [OPTIONS]: one of the following:');
    console.log('       --path <path-to-juttle-file>:          Path to file relative to configured root directory.');
    console.log('                                              Used by "run", "get_inputs", "push", "watch".');
    console.log('       --input name=val:                      One or more input values.');
    console.log('                                              Used by "get_inputs".');
    console.log('       --job <job-id>:                        Job id.');
    console.log('                                              Used by "subscribe", "list_jobs", "delete".');
    console.log('       --observer <observer-id>:              Observer id.');
    console.log('                                              Used by "subscribe", "run"');
    console.log('       --topic <rendezvous-topic>:            Rendezvous topic');
    console.log('                                              Used by "push", "watch".');
    console.log('       --outriggerd <hostname:port>:          Hostname/port of outrigger juttle server');
    console.log('       --help:                                Print this help and exit');
    process.exit(1);
}

function handle_error(err, filename) {

    // The error returned when the request-promise module rejects a
    // promise due to a non-200 status contains an error property that
    // contains the body of the response. (Other errors may not
    // contain this property). If this exists and is JSON, parse it
    // and look for a location. Otherwise, just print the error
    // message.

    var err_obj;
    try {
        err_obj = JSON.parse(err.error);
    } catch (e) {
        // err did not contain a error property or it was not
        // json.
        console.error('ERROR', err.message);
        return;
    }

    // If it's a juttle error containing a program
    // location, print the error in context.
    if (err_obj.code === 'JS-JUTTLE-ERROR') {
        console.error(cli_errors.show_in_context({err: err_obj.info.err,
                                                  program: err_obj.info.bundle.program,
                                                  modules: err_obj.info.bundle.modules,
                                                  filename: filename}));
    } else {
        console.error('ERROR', err.message);
    }
}

function read_inputs(input_args) {

    var inputs = {};
    if (opts.input !== undefined) {
        if (! _.isArray(opts.input)) {
            opts.input = [opts.input];
        }
        _.each(opts.input, function(x) {
            var L = x.split('=');
            if (L.length !== 2) {
                console.error('error: invalid input', x);
                usage();
            }
            var num = +L[1];
            inputs[L[0]] = isNaN(num) ? L[1] : num;
        });
    }

    return inputs;
}

function push_file(filename, topic) {

    return new Promise(function (resolve, reject) {

        console.log('Bundling program ' + filename + ' and pushing to rendezvous topic ' + topic + '...');
        // Open a websocket connection over the rendezvous channel
        var ws = new WebSocket(juttled_noapi_ws_url + '/rendezvous/' + topic);
        ws.on('open', function() {
            // Bundle the program locally and push the bundle over the websocket.
            var bundler = new JuttleBundler();
            bundler.bundle(filename)
                .then(function(bundle) {
                    return new Promise(function (resolve, reject) {
                        ws.send(JSON.stringify(bundle), resolve);
                    });
                })
                .catch(function(err) {
                    // If it's a juttle error containing a program
                    // location, print the error in context.
                    if (err.code === 'JS-JUTTLE-ERROR') {
                        console.error(cli_errors.show_in_context({err: err.info.err,
                                                                  program: err.info.bundle.program,
                                                                  modules: err.info.bundle.modules,
                                                                  filename: filename}));
                    } else {
                        console.error('ERROR', err.message);
                    }
                })
                .finally(function() {
                    ws.close();
                    resolve();
                });
        });
    });
}

function get_file_hash(path) {
    var data = fs.readFileSync(path);
    var shasum = crypto.createHash('sha256');
    shasum.update(data);
    return shasum.digest('hex');
}

_.defaults(opts, defaults);

if (opts.help ||
    opts._.length !== 1) {
    usage();
}

opts.outriggerd = opts['outriggerd'];

var API_PREFIX = '/api/v0';

var juttled_ws_url = 'ws://' + opts.outriggerd + API_PREFIX;
var juttled_noapi_ws_url = 'ws://' + opts.outriggerd;
var juttled_http_url = 'http://' + opts.outriggerd + API_PREFIX;

var command = opts._[0];

switch (command) {

    case 'list_jobs':
        var job_id = opts.job || '';

        rp(juttled_http_url + '/jobs/' + job_id)
            .then(function(body) {
                console.log(JSON.stringify(JSON.parse(body), null, 2));
            }).error(function(e) {
                console.error('ERROR', e.message);
            });

        break;

    case 'list_observers':

        rp(juttled_http_url + '/observers/')
            .then(function(body) {
                console.log(JSON.stringify(JSON.parse(body), null, 2));
            }).error(function(e) {
                console.error('ERROR', e.message);
            });

        break;

    case 'subscribe':
        var ws;

        if (opts.observer !== undefined) {
            console.log('Subscribing to all jobs associated with observer:', opts.observer);
            ws = new WebSocket(juttled_ws_url + '/observers/' + opts.observer);
            ws.on('message', function(message) {
                console.log('received: %s', message);
                var msg = JSON.parse(message);
                if (msg.type === 'ping') {
                    ws.send(JSON.stringify({type: 'pong'}));
                }
            });
            ws.on('close', function(message) {
                console.log('Web socket connection closed, exiting');
                process.exit(0);
            });
        } else if (opts.job !== undefined) {
            console.log('Subscribing to job:', opts.job);
            ws = new WebSocket(juttled_ws_url + '/jobs/' + opts.job);
            ws.on('message', function(message) {
                console.log('received: %s', message);
                var msg = JSON.parse(message);
                if (msg.type === 'ping') {
                    ws.send(JSON.stringify({type: 'pong'}));
                }
            });

            ws.on('close', function(message) {
                console.log('Web socket connection closed, exiting');
                process.exit(0);
            });
        } else {
            usage();
        }

        break;

    case 'delete':
        if (opts.job !== undefined) {
            rp({method: 'DELETE', uri: juttled_http_url + '/jobs/' + opts.job})
                .then(function(body) {
                    console.log(JSON.stringify(JSON.parse(body), null, 2));
                }).error(function(e) {
                    console.error('ERROR', e.message);
                });
        } else {
            usage();
        }

        break;

    case 'run':
        if (opts.path !== undefined) {

            var runInputs = read_inputs(opts.inputs);

            rp(juttled_http_url + '/paths/' + opts.path)
                .then(function(body) {
                    body = JSON.parse(body);
                    return body.bundle;
                }).then(function(bundle) {
                    var body = {
                        bundle: bundle,
                        inputs: runInputs
                    };
                    if (opts.observer) {
                        body.observer = opts.observer;
                    }
                    var post_opts = {
                        method: 'POST',
                        uri: juttled_http_url + '/jobs',
                        headers: {
                            'Content-type': 'application/json'
                        },
                        body: JSON.stringify(body)
                    };
                    return rp(post_opts)
                        .then(function(body) {
                            console.log('Started job', body);
                        });
                }).catch(rp_errors.RequestError, function (e) {
                    console.error('ERROR', e.message);
                }).error(function(e) {
                    handle_error(e, opts.path);
                });
        } else {
            usage();
        }

        break;

    case 'push':

        if (opts.path !== undefined) {
            push_file(path.resolve(opts.path), opts.topic)
            .then(function() {
                console.log('==> View program at: http://' + opts['outriggerd'] + '/run?rendezvous=' + opts.topic);
            });
        } else {
            usage();
        }

        break;

    case 'watch':

        if (opts.path !== undefined) {
            var watchPath = path.resolve(opts.path);
            var last_hash = get_file_hash(watchPath);

            push_file(watchPath, opts.topic)
            .then(function() {
                console.log('==> View program at: http://' + opts['outriggerd'] + '/run?rendezvous=' + opts.topic);
            });

            console.log('Watching file ' + opts.path + ' for changes:');

            chokidar.watch(watchPath).on('change', function(path) {
                var hash = get_file_hash(watchPath);

                if (hash !== last_hash) {
                    push_file(watchPath, opts.topic);
                }

                last_hash = hash;
            });
        } else {
            usage();
        }

        break;

    case 'get_inputs':
        var getInputs = read_inputs(opts.inputs);

        rp(juttled_http_url + '/paths/' + opts.path)
            .then(function(body) {
                body = JSON.parse(body);
                return body.bundle;
            }).then(function(bundle) {
                var body = {
                    bundle: bundle,
                    inputs: getInputs
                };
                var post_opts = {
                    method: 'POST',
                    uri: juttled_http_url + '/prepare',
                    headers: {
                        'Content-type': 'application/json'
                    },
                    body: JSON.stringify(body)
                };
                return rp(post_opts)
                    .then(function(body) {
                        console.log(JSON.stringify(JSON.parse(body), null, 2));
                    });
            }).catch(rp_errors.RequestError, function (e) {
                console.error('ERROR', e.message);
            }).error(function(e) {
                handle_error(e, opts.path);
            });

        break;

    case 'browser':
        if (opts.path) {
            var absPath = path.resolve(opts.path);
            open('http://' + opts['outriggerd'] + '/run?path=' + absPath);

        } else {
            usage();
        }
        break;

    default:
        usage();
}
